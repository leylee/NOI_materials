f[i]=opt{f[x]+w[x][i]}
一、怎样验证为决策单调
若opt为min:
用s(x,i)表示当前状态为x，决策为i时的函数值。
	即s(x,i)=f(x)+w[i,x]
记t为状态x的最优决策，即t=k(x)。
现在已知：s(x,t')>=s(x,t)  (t'<t) ① 即求满足什么条件时有：
	s(x’,t')>=s(x’,t)。(x'<x)  ②

我们可以将①式左边+w[t',x]-w[t',x']，右边+w[t,x]-w[t,x']，即可得到②式，而要不等式成立，就需要：
	  w[t',x]-w[t',x']>=w[t,x]-w[t,x'] (乃充分条件)
最后我们得到：
	w[t',x']+w[t,x]<=w[t',x]+w[t,x']   (t'<t<x<x')
	即w[a,d]+w[b,c]<=w[a,c]+w[b,d] (a<b<c<d)
这就是四边形不等式。对于满足四边形不等式的函数，我们称它为凸函数。
结论：f(x)决策单调等价于w[i,x]为凸函数。

若opt为max:
用s(x,i)表示当前状态为x，决策为i时的函数值。
	即s(x,i)=f(x)+w[i,x]
记t为状态x的最优决策，即t=k(x)。
现在已知：s(x,t')<=s(x,t)  (t'<t) ① 即求满足什么条件时有：
	s(x’,t')<=s(x’,t)。(x'<x)  ②

我们可以将①式左边+w[t',x]-w[t',x']，右边+w[t,x]-w[t,x']，即可得到②式，而要不等式成立，就需要：
	  w[t',x]-w[t',x']<=w[t,x]-w[t,x'] (乃充分条件)
最后我们得到：
	w[t',x']+w[t,x]>=w[t',x]+w[t,x']   (t'<t<x<x')
	即w[a,d]+w[b,c]>=w[a,c]+w[b,d] (a<b<c<d)
这就是四边形不等式。对于满足四边形不等式的函数，我们称它为凸函数。
结论：f(x)决策单调等价于w[i,x]为凸函数。

二、那么如何很快验证四边形不等式？
	对于一个权函数w(i, j)，如果它满足w(x, i + 1) - w(x, i) 随x单调不增，
	亦即w(x, i + 1) + w(x + 1,i) ≥ w(x, i) + w(x +1,i + 1)，
　　则容易证明
　　对任意的a ? b ? c ? d，有w(a, d) + w(b, c)  ? w(a, c) + w(b, d)。
　　
　　小于则为单调不减

三、为什么叫做四边形不等式？
	对于一个凸四边形：
	
如图：A的横左边<b<c<d
AD+BC>AC+BD||AB+CD 对角线之和>两对边之和

四、验证完决策单调之后怎么做？
	1、使用一个栈(stack)来维护数据，栈中元素保存一个决策作为最优决策的起始状态点，显然这些位置相互连接且依次递增。当插入一个新的决策时，从后到前扫描栈，对于每一个老决策来说，做这样两件事：

①、如果在老决策的起点处是新决策好，则退栈，抛弃老决策，将其区间合并至新决策中，继续扫描下一个决策。

②、如果在老决策的起点处是老决策好，则转折点必然在这个老决策的区间中；二分查找，然后新决策进栈，结束。

这个算法的复杂度是O(nlogn)，是非常高效的。

    












